<!DOCTYPE html>
<html property="http://scholarly-html.org/schtml" lang="ro">

<head>
    <meta charset="utf-8">
    <title> Makiko Framework</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <!-- <script src="scholarly.min.js"></script> -->
</head>

<body prefix="schema: http://schema.org">
    <article resource="#" typeof="schema:ScholarlyArticle">
        <header>
            <h1 property="schema:name">Makiko Framework</h1>
        </header>
        <div role="contentinfo">
            <ol role="directory">
                <li>
                    <a href="#introduction"><span>1. </span>Introducere</a>
                </li>
                <li>
                    <a href="#content"><span>2. </span>Componen탵캒</a>
                </li>
                <li>
                    <a href="#creareComponenta"><span>3. </span>Crearea unei componente</a>
                    <ol role="directory">
                        <li><a href="#structuraAplicatiei"><span>3.1 </span>Structura aplica탵iei</a></li>
                        <li><a href="#primaPagina"><span>3.2 </span>Prima pagin캒</a></li>
                        <li><a href="#rutare"><span>3.3 </span>Rutarea</a></li>
                    </ol>
                </li>
                <li>
                    <a href="#utilitareFramework"><span>4. </span>Func탵ii utilitare</a>
                    <ol role="directory">
                        <li><a href="#alerta"><span>4.1 </span>Alert box</a></li>
                        <li><a href="#creareElemente"><span>4.2 </span>Func탵ii pentru crearea 탳i modificarea elementelor
                                din DOM</a></li>
                        <!-- <li><a href="#animatii"><span>4.4 </span>Crearea anima탵iilor vectoriale</a></li> -->
                    </ol>
                </li>
                <li>
                    <a href="#animatiiSVG"><span>5. </span> Anima탵ii SVG </a>
                    <ol>
                        <li><a href="#animatiiPrelucrare"><span>5.1</span> Prelucrare SVG</a></li>
                        <li><a href="#animatiiConstructie"><span>5.2 </span> Constructori </a></li>
                        <li><a href="#animatiiFunctii"><span>5.3 </span> Func탵ii de anima탵ii cu obiecte SVG </a></li>
                        <li><a href="#animatiiFunctiiAjutatoare"><span>5.4 </span> Func탵ii cu obiecte SVG</a></li>
                    </ol>
                </li>
                <li>
                    <a href="#crearePet"><span>6. </span> Crearea unui nou animalut</a>
                    <ol>
                        <li><a href="#generarePet"><span>6.1 </span> Generare nou pet (add-pet)</a></li>
                        <li><a href="#jocPet"><span>6.2 </span> Introducerea noului pet in joc</a></li>
                    </ol>
                </li>
            </ol>
            <section typeof="sa:AuthorsList">
                <h2>Authors</h2>
                <ul>
                    <li typeof="sa:ContributorRole" property="schema:contributor">
                        <span typeof="schema:Person">
                            <meta property="schema:givenName" content="Diana">
                            <meta property="schema:familyName" content="Ilisei">
                            <span property="schema:name">Diana Ilisei</span>
                        </span></li>
                    <li typeof="sa:ContributorRole" property="schema:contributor">
                        <span typeof="schema:Person">
                            <meta property="schema:givenName" content="Cristiana">
                            <meta property="schema:familyName" content="Ant캒lu탵">
                            <span property="schema:name">Cristiana Ant캒lu탵</span>
                        </span></li>
                </ul>
            </section>
        </div>
        <section role="doc-introduction" id="introduction">
            <h2 property="schema:alternateName">1. Introducere</h2>
            <p>Framework-ul Makiko este un mini framework MVC pentru dezvoltarea de aplica콖ii Web animate vectoriale la
                nivel de client. Acesta ofer캒 at칙t func탵ii speciale pentru a 칥ndeplini sarcinile de baz캒 ale unui
                framework c칙t 탳i metode de a crea anima탵ii pentru template-uri SVG. Mai mult dec칙t at칙t, cu ajutorul
                framework-ului se pot construi aplica탵ii web SPA.</p>
        </section>
        <section id="content">
            <h2 property="schema:alternateName">2. Componen탵캒</h2>
            <p>Pentru a func탵iona, Makiko are nevoie de c칙teva fi탳iere care asigur캒 rutarea 칥ntre paginile aplica탵iei
                SPA, randarea componentelor la schimb캒ri 칥n model 탳i, de asemenea, asigur캒 conexiunea 칥ntre controller,
                component캒 탳i view.</p>
            <ul>
                <li>/js/framework.js</li>
                <li>/js/helpers.js</li>
                <li>/js/router.js</li>
                <li>/css/style.css</li>
                <li>index.html</li>
            </ul>
        </section>
        <section id="creareComponenta">
            <h2 property="schema:alternateName">3. Crearea unei componente</h2>
            <section id="structuraAplicatiei">
                <h4>1. Structura aplica탵iei</h4>
                <p>Pentru a implementa framework-ul este nevoie de o pagina <code>index.html</code> 칥n care vor fi puse
                    componentele,
                    adic캒
                    paginile propriu zise ale aplica탵iei. Acestea vor fi injectate 칥n singurul div din body:</p>
                <figure typeof="schema:SoftwareSourceCode" resource="#doc-example">
                    <pre>
                    <code>
&lt;DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=devide-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Makiko&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div view&gt;
    &lt;/div&gt;
    &lt;script src="./js/helpers.js"&gt;&lt;/script&gt;
    &lt;script src="./js/framework.js"&gt;&lt;/script&gt;
    &lt;script src="./js/router.js"&gt;&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
                    <figcaption><i>Fisierul <code>index.html</code>.</i></figcaption>
                </figure>
                <p>Pentru o separare mai bun캒 a fi탳ierelor, este recomandat s캒 existe urm캒toarea structur캒 de
                    directoare:
                </p>
                <ul>
                    <li>/controllers</li>
                    <li>/views</li>
                    <li>/css</li>
                    <li>/js</li>
                    <li>index.html</li>
                </ul>
                <p>칉n <code>controllers</code> se vor p캒stra controllerele aferente fiec캒rei pagini din aplica탵ie, iar
                    칥n
                    <code>views</code> vor fi fi탳ierele <code>html</code>, cu alte cuvinte, componentele aplica탵iei.
                    칉n <code>js</code> r캒m칙n doar fi탳ierele ce 탵in de framework-ul Makiko.</p>
            </section>
            <section id="primaPagina">
                <h4>3.2 Prima pagin캒</h4>
                <p>Spre exemplu, dorim s캒 cre캒m pagina Home a unei aplica탵ii. Pentru aceasta, 칥n folderul
                    <code>views</code> cre캒m un fi탳ier <code>home.html</code> 칥n care ad캒ug캒m:</p>
                <figure typeof="schema:SoftwareSourceCode" resource="#doc-example">
                    <pre>
                        <code>
&lt;p&gt;
    Hello world!
&lt;/p&gt;    </code></pre>
                    <figcaption><i>Fi탳ierul <code>./views/home.html</code>.</i></figcaption>
                </figure>
                <p>칉n directorul <code>controllers</code> cre캒m fi탳ierul <code>homeController.js</code>.</p>
                <figure typeof="schema:SoftwareSourceCode" resource="#doc-example">
                    <pre>
                            <code>
function HomeController(view, model) {
    
}</code></pre>
                    <figcaption><i>Fisierul <code>./js/homeController.js</code>.</i></figcaption>
                </figure>
                <p>Din aceast캒 func탵ie putem s캒 manipul캒m at칙t fi탳ierele <code>css</code> 탳i <code>js</code> pe care le
                    vrem inserate la 칥nc캒rcarea componentei, c칙t 탳i datele p캒strate 칥n obiectul <code>model</code> al
                    fiec캒rei pagini. Framework-ul pune la dispozi탵ie c칙teva func탵ii prin care se pot ad캒uga/칥nl캒tura
                    asset-uri din pagina specific캒 controller-ului. 칉n exemplul de mai jos, 칥nl캒tur캒m toate fi탳ierele
                    css 탳i js corespunz캒toare altor componente 칥nc캒rcate anterior 탳i le ad캒ug캒m pe acelea necesare
                    paginii pe care am navigat.</p>
                <figure typeof="schema:SoftwareSourceCode" resource="#doc-example">
                    <pre>
                                    <code>
function HomeController(view, model) {
    view.removeLastCssLink();
    view.addCssLink('css/home.css');
    view.removeLastScripts();
    view.addScript('menuBar.js');
}</code></pre>
                    <figcaption><i>Fisierul <code>./js/homeController.js</code>.</i></figcaption>
                </figure>
                <p>Tot 칥n aceast캒 func탵ie putem modifica datele din modelul paginii, iar pentru a afi탳a 칥n componenta
                    Home valorile din model, scriem variabila astfel: <code>{{nume_variabila}}</code>.</p>
                <figure typeof="schema:SoftwareSourceCode" resource="#doc-example">
                    <pre>
                                            <code>
function HomeController(view, model) {
    view.removeLastCssLink();
    view.addCssLink('css/home.css');
    view.removeLastScripts();
    view.addScript('menuBar.js');
    model.mesaj = "I am Makiko.";
}</code></pre>
                    <figcaption><i>Fisierul <code>./js/homeController.js</code>.</i></figcaption>
                </figure>
                <figure typeof="schema:SoftwareSourceCode" resource="#doc-example">
                    <pre>
                        <code>
&lt;p&gt;
    Hello world, {{ mesaj }}
&lt;/p&gt;    </code></pre>
                    <figcaption><i>Fisierul <code>./views/home.html</code>.</i></figcaption>
                </figure>
                <p>Atunci c칙nd decidem c캒 vom mai avea o component캒, trebuie s캒 ad캒ug캒m 칥n
                    <code>index.html</code> script-ul controller-ului acelei componente.</p>
            </section>

            <section id="rutare">
                <h4>3.3 Rutarea</h4>
                <p>Pentru a realiza rutarea 칥ntre componente, 칥n fi탳ierul <code>./js/router.js</code>, 칥nainte de linia
                    de cod prin care framework-ul ini탵ializeaz캒 rutele ad캒ugate trebuie s캒 ad캒ug캒m urm캒toarea linie:</p>
                <figure typeof="schema:SoftwareSourceCode" resource="#doc-example">
                    <pre>
                                <code>
Framework.AddRoute(HomeController, 'home', 'views/home.html'); 
Framework.Initialize();</code></pre>
                    <figcaption><i>Fisierul <code>./js/router.js</code>.</i></figcaption>
                </figure>
                <p>Primul argument al func탵iei <code>AddRoute</code> este chiar controller-ul specific paginii, al
                    doilea reprezint캒 numele componentei iar ultimul face leg캒tura celor dou캒 cu fi탳ierul
                    <code>html</code> corespunz캒tor.</p>
                <p>Astfel, pagina home va putea fi accesat캒 prin URL-ul: <code>http://localhost:7000/#home</code> 탳i
                    pagina va ar캒ta astfel:</p>
                <figure typeof="sa:image">
                    <img style="width: 100%;" src="./resources/firstpage.png" alt="first page demo">
                    <figcaption><i>Screen shot prima pagin캒. </i></figcaption>
                </figure>
            </section>
        </section>
        <section id="utilitareFramework">
            <h2 property="schema:alternateName">4. Func탵ii utilitare</h2>
            <p>Aici g캒si탵i o list캒 cu cele mai importante func탵ii puse la dispozi탵ie de framework:</p>
            <section id="alerta">
                <h4>4.1 Alert box</h4>
                <p>Framework-ul Makiko ofer캒 o alert캒 proprie care poate fi apelat캒 prin
                    <code>Alert.render("mesaj")</code></p>
            </section>
            <section id="creareElemente">
                <h4>4.2 Func탵ii pentru crearea 탳i modificarea elementelor din DOM</h4>
                <p>Din moment ce componentele sunt ad캒ugate 칥n mod dinamic, crearea dinamic캒 de noi elemente este
                    necesar캒. Pentru a evita repeti탵ia acelora탳i comenzi pentru elemente diferite, framework-ul Makiko
                    pune la dispozi탵ie o func탵ie capabil캒 s캒 creeze elemente noi cu propriet캒탵i diferite. De asemenea,
                    exist캒 탳i func탵ii prin care se pot modifica dinamic elemente deja existente.</p>
                <ul>
                    <li><code>createElement(tagName, classNames, id, text, attributes, datasets)</code>
                        <ul>
                            <li><code>tagName</code> - numele tag-ului noului element (de ex: "div", "p", "img");
                                valoare implicita: ''</li>
                            <li><code>classNames</code> - list캒 cu toate clasele ce vor fi ad캒ugate elementului (de ex:
                                ['div-wrapper', 'aside-background']); valoare implicita: []</li>
                            <li><code>id</code> - valoarea id-ului noului element (de ex: "login-form"); valoare
                                implicit캒: ''</li>
                            <li><code>text</code>- textul ce va fi inserat 칥ntre tag-urile corespunz캒toare noului
                                element - <code>innerText</code> (de ex: "mesaj"); valoare implicit캒: ''</li>
                            <li><code>attributes</code> - obiect ce con탵ine perechi <code>nume_atribut: valoare</code>
                                (de ex: {"src": "./resources/logo.png", "alt": "logo"}); valoare implicit캒: {}</li>
                            <li><code>datasets</code> - obiect ce con탵ine perechi
                                <code>nume_atribut_custom: valoare</code> (de ex: {"idUser": "1234"}); valoare
                                implicit캒: {}</li>
                        </ul>
                    </li>
                    <li><code>addClass(idElement, className)</code> - adaug캒 clasa <code>className</code> la elementul
                        din DOM identificat prin <code>idElement</code></li>
                    <li><code>appendChildren(element, children)</code> - adaug캒 lista de elemente <code>children</code>
                        칥n <code>element</code></li>
                </ul>
            </section>
        </section>
        <section id="animatiiSVG">
            <h2>5. Anima탵ii SVG</h2>
            <section id="animatiiPrelucrare">
                <h4>5.1 Prelucrarea obiectelor vectoriale</h4>
                <p>Frameworkul Makiko ofer캒 5 obiecte SVG, modele de anim캒lu탵e.
                    Utilizatorul are posibilitatea de a adauga noi anim캒lu탵e 칥n formatul SVG.
                    Pentru o u탳oar캒 manipulare a obiectelor este necesar캒 utilizarea urm캒toarelor clase:
                </p>
                <ul>
                    <li>class="pet-eyes";</li>
                    <li>class="pet-body".</li>
                </ul>
                <p>Prin atribuirea acestor clase, putem efectua dinamic, modific캒ri asupra elementelor SVG.</p>
                <figure typeof="schema:SoftwareSourceCode" resource="#doc-example">
                    <pre> <code>
&lt;svg width="170" height="170" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"&gt;
    &lt;ellipse class="pet-body" style="fill :#ffffff" ry="48.5" rx="53.5" id="svg_54" cy="79.98" cx="83.98" ... &gt;
    &lt;path d="m59.5933,129.46832c- ..." &gt;
    &lt;path class="pet-eyes" fill="black" d="m82.7933,75.66832c-..." &gt;
    &lt;path class="pet-eyes" d="m115.2933,75.6 ..." &gt;
    &lt;path  fill="#F15A29" d="m92.0933,95.66832c0,0 ... " &gt;
&lt;/svg&gt;
                    </code> </pre>
                    <figcaption><i>Fi탳ierul <code>./resources/pet.svg</code>.</i></figcaption>
                </figure>
                <p>Pentru a putea utiliza 탳i modifica obiectele SVG, acestea vor fi ad캒ugate 칥n HTML sub urm캒torul
                    format:</p>
                <pre><code>
&lt;template id="[tip-animal]"&gt;
    &lt;svg&gt;
        <i>...</i>
    &lt;/svg&gt;
&lt;/template&gt;
&lt;template id="[tip2-animal]"&gt;
    &lt;svg&gt;
        <i>...</i>
    &lt;/svg&gt;
&lt;/template&gt;
                    </code></pre>
            </section>
            <section id="animatiiConstructie">
                <h4>5.2 Constructorii obiectelor</h4>
                <p>Punem la dispozi탵ia utilizatorului doi constructori: <i>addPetConstructor()</i>, utilizat pentru a
                    adauga un nou anim캒lu탵 칥n playground 탳i <i>petConstructor()</i> pentru procesarea 탳i prelcrarea
                    datelor
                    칥n timpul interac탵iunii cu anim캒lu탵ul.</p>
                <p>Constructorul <i>addPetConstructor()</i>:</p>
                <ul>
                    <li>Atribute: name, type, age, gender, bodyColor, eyesColor, description ;</li>
                    <li>Metode: updateAll(<i>...</i>), updateName(name), updateType(type), updateAge(age),
                        updateGender(gender), updateBodyColor(bodyColor), updateEyesColor(eyesColor),
                        updateDescription(description).</li>
                </ul>
                <p>Fiecare metod캒 are corespondent un atribut pentru a acorda utilizatorului libertatea de a alege
                    combina탵ia de atribute dorit캒.</p>
                <br>
                <p>Constructorul <i>petConstructor()</i>:</p>
                <ul>
                    <li>Atribute: id, name, type, animationOption, foodLevel, sympathyLevel, energyLevel, bodyColor,
                        eyesColor, description, age, xp;</li>
                    <li>Metode:
                        <ul>
                            <li><i>changeAnimationSleepy()</i>: Func탵ionalitate ce apar탵ine elementului petState.
                                Incrementeaz캒 statusul atributului energyLevel, cu constanta <i>NR_INCREMENT</i> 탳i
                                schimb캒 reac탵ia pet-ului(<i>petReaction</i>) cu: 游눣. </li>
                            <li><i>changeAnimationFood()</i>: Func탵ionalitate ce apar탵ine elementului petState.
                                Incrementeaz캒 statusul atributului foodLevel, cu constanta <i>NR_INCREMENT</i> 탳i
                                schimb캒 reac탵ia pet-ului(<i>petReaction</i>) cu: 游꾹.</li>
                            <li><i>changeAnimationHeart()</i>: Func탵ionalitate ce apar탵ine elementului petState.
                                Incrementeaz캒 statusul atributului sympathyLevel, cu constanta <i>NR_INCREMENT</i> 탳i
                                schimb캒 reac탵ia pet-ului(<i>petReaction</i>) cu: 游눘.</li>
                            <li><i>showPetState()</i>: petState este format din combina탵ii:(foodLevel, energyLever,
                                sympathyLevel). Aceast캒 func탵ie permite vizualizarea petState 탳i a func탵ionalit캒탵ilor
                                oferite de aceste trei op탵iuni, prin hover asupra componentei pet.</li>
                            <li><i>hidePetState()</i>: Pentru a nu 칥nc캒rca spa탵iul vizibil, aceast캒 func탵ie ascude
                                petState
                                atunci c칙nd focusul(mouse) nu este axat pe componenta pet-ului pe care 칥l serve탳te.</li>
                            <li><i>doSpecificAnimation()</i>: La modificarea unui indicator petStatus, aceast캒 func탵ie
                                permite desf캒탳urarea anima탵iei aleas캒 prin <i>animationOption</i> 탳i porne탳te anima탵ia
                                pentru <i>petReaction</i>.</li>
                            <li><i>decreaseStatus()</i>: Func탵ie de contorizare. Aceast캒 func탵ie se autoapeleaz캒 탳i
                                ofer캒 modalitatea de a descre탳te atributele 칥ncorporate 칥n petState cu un num캒r constant
                                <i>NR_DECREMENT</i>. Aceast캒 func탵ie face apelul update la baza de date pentru a updata
                                c칙mpurile corespunz캒toare petState.</li>
                            <li><i>changeMood()</i>: Func탵ie ce modific캒 obiectul SVG pet conform petState. Dac캒 un
                                petStatus (energyLevel, foodLevel, sympathyLevel) este sub o limit캒 stabilit캒 de
                                utilizator, acesta "devine bolnav", iar culoarea lui se modific캒.</li>
                        </ul>
                    </li>
                </ul>
            </section>
            <section id="animatiiFunctii">
                <h4>5.3 Func탵ii de Anima탵ii cu Obiecte SVG</h4>
                <p>Am pus la dispozi탵ia utilizatorului 7 func탵ii de anima탵ii pentru pets, formate din una sau mai multe
                    combina탵ii de op탵iuni CSS animation.
                    Func탵iile sunt transmise ca op탵iuni la crearea obiectului prin atributul animationOption din
                    petConstructor.</p>
                <p> (칉n exemplul nostru am utilizat o func탵ie random pentru a alege op탵iunea, iar la fiecare GET din DB,
                    obiectul prime탳te alt캒 op탵iune. Astfel utilizatorul se poate bucura de toate anima탵iile, chiar dac캒
                    are un singur pet.)</p>
                <p>Obiectul petContainer primeste una din clasele animatiilor urmatoare. Animatiile sunt atribuite pe
                    baza petId, transmis ca parametru.</p>

                <p>Func탵ii de anima탵ii:</p>
                <ul>
                    <li><i>rollAndMoveRight(id)</i>: class="rollAndMoveRight", definit prin transform cu op탵iunile
                        translate 탳i rotate;</li>
                    <li><i>rollAndMoveLeft(id)</i>: class="rollAndMoveLeft", definit prin transform cu op탵iunile
                        translate 탳i rotate;</li>
                    <li><i>movePetRight(id)</i>: class="movePetRight", definit prin transform cu op탵iunea translate;
                    </li>
                    <li><i>movePetLeft(id)</i>: class="movePetLeft", definit prin transform cu op탵iunea translate;</li>
                    <li><i>rollPet(id)</i>: class="rollPet", definit prin transform cu op탵iunea rotate;</li>
                    <li><i>jumpUp(id)</i>: class="jumpUp", definit prin transform cu op탵iunile scale 탳i translate;</li>
                    <li><i>removeClassAnimation(id)</i>: elimina clasele corespunztoare anima탵iilor din containerul
                        pet-ului. </li>
                </ul>
            </section>
            <section id="animatiiFunctiiAjutatoare">
                <h4>5.4 Func탵ii cu obiecte SVG</h4>
                <p>Fiecare anim캒lu탵, atunci c칙nd este generat, poate avea orice culoare dore탳te utilizatorul.
                    Pentru a modifica culorile pet-ului, utiliz캒m 2 func탵ii: <i>changePetColor()</i> 탳i
                    <i>changePetEyesColor()</i>.
                    Ambele func탵ii func탵ioneaza pe acela탳i principiu, modificarea culorii clasei selectate(pet-eyes,
                    pet-body) cu cea din obiectul pet(parametrul 1) 칥n obiectul SVG(petContent, parametrul 2).
                    Func탵ia <i>changeMood()</i>, men탵ionat캒 칥n <a href="#animatiiConstructie">petConstructor()</a>,
                    utilizeaz캒 aceste func탵ii.</p>
                <pre><code>
function changePetColor(pet, petContent) {
    var petColor = petContent.getElementsByClassName("pet-body");
    for (var i = 0; i &lt; petColor.length; i++) {
        petColor.item(i).style.fill = pet.bodyColor;
    }
}
                </code></pre>
                <pre><code>
function changePetEyesColor(pet, petContent) {
    var petEyes = petContent.getElementsByClassName("pet-eyes");
    for (var i = 0; i &lt; petEyes.length; i++) {
        petEyes.item(i).style.fill = pet.eyesColor;
    }
}
                </code></pre>
            </section>
        </section>
        <section id="crearePet">
            <h2>6. Crearea unui nou anim캒lu탵</h2>
            <section id="generarePet">
                <h4>Generarea noului Pet</h4>

                <p>Va con탵ine urm캒toarele:</p>
                <ul>
                    <li>Formularul cu op탵iunile disponibile din addPetConstructor(). Fiecare tag de input are ca
                        func탵ie pentru atributul <i>onchange</i> func탵ia din constructor corespunz캒toare atributului
                        pe care 칥l define탳te</li>
                    <li>Un container pentru pet</li>
                    <li>Ad캒ugarea pet templates conform formatului de la <a href="#animatiiPrelucrare">Prelucrarea
                            obiectelor vectoriale</a></li>
                </ul>


                <p>Va con탵ine urmatoarele:</p>
                <ul>
                    <li>Folosind <a href="#animatiiConstructie">addPetConstructor()</a> declar캒m un nou obiect.</li>
                    <li>EventListener pe formularul din HTML.</li>
                    <li>Apelul POST c캒tre DataBase.</li>
                </ul>

            </section>
            <section id="jocPet">
                <h4>Introducerea noului pet 칥n joc</h4>
                <p>Va con탵ine urm캒toarele:</p>
                <ul>
                    <li>Un container pentru pets</li>
                    <li>Ad캒ugarea unui template cu propriet캒탵ile din <a href="#animatiiConstructie">petConstructor()</a>
                        pe care dorim s캒 le utiliz캒m.
                        <pre><code>
&lt;template id="templatePetWrapper"&gt;
    &lt;div class="pet-wrapper"&gt;
        &lt;div class="pet-reaction"&gt;游눘&lt;/div&gt;
        &lt;div class="pet-state"&gt;
            &lt;div class="pet-state-flex"&gt;
                &lt;div class="pet-xp"&gt;&lt;/div&gt;
                &lt;div class="pet-status&gt;
                    &lt;label for="food-level"&gt;
                        &lt;img class="img-pet food" alt="pet saturation level" src="../resources/*.png"&gt;
                    &lt;/label&gt;
                    &lt;meter class="food-level" min="6" max="200" low="50" high="120" optimum="150" value="50"&gt; &lt;/meter&gt;
                &lt;/div&gt;
                &lt;div class="pet-status"&gt;
                    &lt;label for="sympathy-level"&gt;
                        &lt;img class="img-pet heart" alt="pet affection level" src="../resources/*.png"&gt;
                    &lt;/label&gt;
                    &lt;meter class="sympathy-level" min="6" max="200" low="50" high="120" optimum="150" value="180"&gt; &lt;meter&gt;
                &lt;/div&gt;
                &lt;div class="pet-status"&gt;
                    &lt;label for="energy-level"&gt;
                        &lt;img class="img-pet sleepy" alt="pet affection level" src="../resources/*.png"&gt;
                        &lt;/label&gt;
                    &lt;meter class="energy-level" min="6" max="200" low="50" high="120" optimum="150" value="180"&gt;&lt;/meter&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="pet-content"&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
                        </code></pre>


                    </li>
                    <li>A캒augarea pet templates conform formatului de la <a href="#animatiiPrelucrare">Prelucrarea
                            obiectelor vectoriale</a></li>
                </ul>

                <p>Va con탵ine urm캒toarele:</p>
                <ul>
                    <li>Apelul GET catre DB, care 칥ntoarce obiectul pet creat conform: <a href="#generarePet">generare
                            Pet</a></li>
                    <li>Folosind <a href="#animatiiConstructie">petConstructor()</a> declar캒m un nou obiect cu
                        r캒sponsul returnat de apelul GET prin func탵ia <i>AddPetToPlayground(pet)</i>.
                        Urmeaz캒 o serie de func탵ii apar탵in칙nd frameworkului, care 칥ntroduc conform templateului de
                        mai sus un nou obiect pet pe pagina de joc.
                        <pre><code>
function AddPetToPlayground(pet) {
    var petWrapperAll = document.getElementById("pets-wrapper-all");
    pets.push(pet);
    var newpet = `&lt;div class="pet-wrapperCont" data-insert-pet="pets[${pets.length - 1}]" onclick="pets[${pets.length - 1}].doSpecificAnimation(${this.animationOption})" onmouseover="pets[${pets.length - 1}].showPetState()"
    onmouseout="pets[${pets.length - 1}].hidePetState()"&gt;&lt;/div&gt;`;
    petWrapperAll.innerHTML += newpet;
    addTemplatesContainer();
}

function addTemplatesContainer() {
    var elements = document.getElementsByClassName("pet-wrapperCont");
    let templ = document.getElementById("templatePetWrapper");
    for (let i = 0; i &lt; pets.length; i++) {
        elements[i].innerHTML = templ.innerHTML;
    }
    AddSpecificationAfterTemplates();
}

function AddSpecificationAfterTemplates() {
    var elements = document.querySelectorAll("[data-insert-pet]");
    if (elements) {
        for (var i = 0; i &lt; elements.length; i++) {
            var currentElement = elements[i];
            var currentPet = eval(currentElement.dataset.insertPet);
            currentElement.querySelector(".pet-reaction").id = currentPet.id + "-reaction";
            var currentStateElement = currentElement.querySelector(".pet-state");
            currentStateElement.id = currentPet.id + "-state";
            addStateFood(currentPet, currentStateElement);
            addStateLove(currentPet, currentStateElement);
            addStateEnergy(currentPet, currentStateElement);
            addPetSVG(currentElement, currentPet);
        }
    }
}

function addStateEnergy(currentPet, currentStateElement) {
    var energyLevelEl = currentStateElement.querySelector(".energy-level");
    energyLevelEl.id = currentPet.id + "-energy-level";
    energyLevelEl.value = currentPet.energyLevel;
    var energyImg = currentStateElement.querySelector(".sleepy");
    energyImg.id = currentPet.id + "-sleepy";
    var energy = document.getElementById(`${currentPet.id}-sleepy`);
    energy.setAttribute('onclick', `pets[${pets.indexOf(currentPet)}].changeAnimationSleepy()`);
}

function addPetSVG(currentElement, currentPet) {
    var currentPetContent = currentElement.querySelector(".pet-content");
    currentPetContent.id = currentPet.id + "-content";
    var petImage = document.getElementById(currentPet.type);
    petContent = document.getElementById(`${currentPet.id}-content`);
    petContent.innerHTML = petImage.innerHTML;
    changePetColor(currentPet, petContent);
    changePetEyesColor(currentPet, petContent);
}                              
                        </code></pre>


                    </li>
                    <li>Apelul POST c캒tre DataBase.</li>
                </ul>

            </section>
        </section>
    </article>
</body>

</html>